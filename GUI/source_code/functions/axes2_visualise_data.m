function axes2_visualise_data(handles)
%This function is called when user pushes the "Visualise" button on axes2
%        Author:
%              Arthur Chakwizira
%              arthur.chakwizira@med.lu.se
%             Medical Radiation Physics, Lund University, Sweden
hObject  = handles.hObject;
handles = guidata(hObject);

if isfield(handles, 'axes2_folder')
    file_folder = handles.axes2_folder;
elseif isfield(handles, 'file_folder')
    file_folder = handles.file_folder;
else; file_folder = [];
end
[file, path] = uigetfile('*', 'Select data to visualise', file_folder);
if file == 0
    report('No data selected for visualisation', handles, 'r')
    return;
else
    set([handles.pushbutton31, handles.pushbutton32,handles.pushbutton33, handles.pushbutton34, handles.pushbutton35], 'Visible', 'off') %initially turn off all these buttons
     set(handles.figure1, 'WindowButtonMotionFcn', []);
    %     set([handles.pushbutton24, handles.pushbutton25,handles.pushbutton26, handles.pushbutton27, handles.pushbutton30], 'Visible', 'off') %initially turn off all these buttons
    cla(handles.axes2, 'reset')
    set(handles.axes2,'XTick', [], 'YTick', [])
    set(handles.axes2, 'box', 'on')
    cla(handles.axes2, 'reset')
    %     set(handles.axes1,'XTick', [], 'YTick', [])
%     set(handles.axes1, 'box', 'on')
    set(handles.slider1, 'Visible', 'off')
    handles.plotting_4d_data = false;
    handles.data_onto_axes2 = true;
    path_to_axes2_data = fullfile(path, file);
    wrap_text = ['Visualising data from ' path_to_axes2_data];
    set(handles.edit7, 'String', wrap_text, 'ForegroundColor', 'b')
    [base_folder, file_name, file_ext] = fileparts(path_to_axes2_data);
    %recognise files generated by DECONVOLVER and read them accordingly
    switch file_name
        case {'cbf_BzD', 'cbf_SVD', 'cbv_as_cbf_times_mtt_BzD', 'cbv_as_cbf_times_mtt_SVD', 'cbv_without_deconvolution', 'cmro2_BzD', 'cmro2_SVD',...
                'delay_BzD', 'delay_SVD', 'mtt_as_area_under_r_BzD', 'mtt_as_area_under_r_SVD', 'mtt_as_cbv_over_cbf_BzD', 'mtt_as_cbv_over_cbf_SVD',...
                'oef_BzD', 'oef_SVD', 'ttp_from_calculated_signal_SVD', 'ttp_from_fitted_signal_BzD', 'ttp_without_deconvolution'}; num_dims = 3;
        case {'residue_functions_BzD', 'residue_functions_SVD', 'control_points_BzD', 'disp_kernel_BzD'}; num_dims = 4;
        otherwise; num_dims = false;
    end
    axes2_pre_data = read_this_file(fullfile(path, file),num_dims);
    if isstruct(axes2_pre_data)
        axes2_data = squeeze(axes2_pre_data.the_data); %remove singular dimensions as they will confuse sliders
        handles.header_info = axes2_pre_data.the_info;
    else
        if isequal(axes2_pre_data, false)
            return
        else
            axes2_data = squeeze(axes2_pre_data);
        end
    end

    size_axes2_data = size(axes2_data);
    handles.size_axes2_data = size_axes2_data;
    handles.axes2_data = axes2_data;
    handles.path_to_axes2_data = path_to_axes2_data;
    handles.axes2_filename = file_name;
    handles.axes2_folder = base_folder;
    handles.use_dsc_data_for_roi = false;
    guidata(hObject, handles)

    if length(size_axes2_data) == 2 %2D or 1D
        if ~isempty(size_axes2_data(size_axes2_data == 1)) %1D data
            visualise_1D_data(hObject)
        else %if 2D image
            visualise_2D_data(hObject)
        end
    end

    if length(size_axes2_data) == 3 %3D data
        if ( strcmp(file_ext, '.png') || strcmp(file_ext, '.PNG') ...
                || strcmp(file_ext, '.jpg') || strcmp(file_ext, '.JPG') || ...
                strcmp(file_ext, '.JPEG') || strcmp(file_ext, '.gif') || strcmp(file_ext, '.ico'))
            visualise_photos(hObject)
        else
            visualise_3D_data(hObject)
        end
    end

    if length(size_axes2_data) == 4
        visualise_4D_data(hObject)
    end

end
end
%% aux
function visualise_1D_data(hObject)
handles = guidata(hObject);
handles.axes2_data = double(handles.axes2_data);
set(handles.slider2, 'Visible', 'off')
set(handles.slider7, 'Visible', 'off')
set(handles.slider11, 'Visible', 'off')
set(handles.slider9, 'Visible', 'off')
set(handles.pushbutton16, 'Visible', 'off')
set(handles.pushbutton18, 'Visible', 'off')%rotate image on axes2
set(handles.togglebutton3, 'Visible', 'off')
d_x = 1;
x = 0:d_x:d_x*(max(handles.size_axes2_data)-1);
plot(x, handles.axes2_data, 'k-','LineWidth',2, 'Parent', handles.axes2)
title(handles.axes2, handles.axes2_filename, 'Interpreter', 'none')
xlabel(handles.axes2, 'x')
ylabel(handles.axes2, 'y')
set(handles.axes2, 'fontsize', 11)
grid(handles.axes2, 'on')
guidata(hObject, handles)
end

function visualise_2D_data(hObject)
handles = guidata(hObject);
handles.axes2_data = double(handles.axes2_data);
set(handles.pushbutton35, 'String', 'Show data in ROI(s)');
set(handles.pushbutton35, 'Visible', 'on');
set(handles.pushbutton35, 'Callback', {@Show2D})
set(handles.pushbutton33, 'Visible', 'on');
set(handles.pushbutton31, 'Visible', 'on');
set(handles.pushbutton33, 'Callback', {@addROI});
set(handles.pushbutton31, 'Callback', {@clearROIs_2D});
set(handles.slider2, 'Visible', 'off');%slices
set(handles.slider9, 'Visible', 'off'); %time point
set(handles.slider7, 'Visible', 'on') %color
set(handles.slider11, 'Visible', 'on') %color
set(handles.pushbutton16, 'Visible', 'on') %colormap, ok
set(handles.pushbutton18, 'Visible', 'off')%rotate image on axes2; not allowing this anymore due to ROI placement functionality
set(handles.togglebutton3, 'Visible', 'on') %colorbar, ok
guidata(hObject, handles)
initialise_roi_placement(hObject);
prepare_sliders_2D(hObject)
end

function visualise_3D_data(hObject)
handles = guidata(hObject);
handles.axes2_data = double(handles.axes2_data);
set(handles.pushbutton35, 'String', 'Show data in ROI(s)');
set(handles.pushbutton35, 'Visible', 'on');
set(handles.pushbutton35, 'Callback', {@Show3D})
set(handles.pushbutton33, 'Visible', 'on');
set(handles.pushbutton31, 'Visible', 'on');
set(handles.pushbutton33, 'Callback', {@addROI});
set(handles.pushbutton31, 'Callback', {@clearROIs_3D});
set(handles.pushbutton16, 'Visible', 'on') %colormap, ok
set(handles.pushbutton18, 'Visible', 'off')%rotate image on axes2; not allowing this anymore due to ROI placement functionality
set(handles.togglebutton3, 'Visible', 'on') %colorbar, ok
set(handles.slider2, 'Callback', {@change_slice_3D});
guidata(hObject, handles)
initialise_roi_placement(hObject);
prepare_sliders_3D(hObject)
end

function visualise_4D_data(hObject)
handles = guidata(hObject);
handles.axes2_data = double(handles.axes2_data);
%plotting residue funcs might be easier when ROI is placed on DSC image not
%on residue func image. Ask user to load DSC data if it doesn't already
%exist
set(handles.pushbutton35, 'String', 'Show data in ROI(s)');
set(handles.pushbutton35, 'Visible', 'on');
set(handles.pushbutton35, 'Callback', {@Show4D})
set(handles.pushbutton33, 'Visible', 'on');
set(handles.pushbutton31, 'Visible', 'on');
set(handles.pushbutton33, 'Callback', {@addROI});
set(handles.pushbutton31, 'Callback', {@clearROIs_4D});
set(handles.pushbutton16, 'Visible', 'on') %colormap, ok
set(handles.pushbutton18, 'Visible', 'off')%rotate image on axes2; not allowing this anymore due to ROI placement functionality
set(handles.togglebutton3, 'Visible', 'on') %colorbar, ok
set(handles.slider2, 'Callback', {@change_slice_4D});
set(handles.slider9, 'Callback', {@change_timepoint});
set(handles.figure1, 'WindowButtonMotionFcn', {@mouseMove});
guidata(hObject, handles)
check_if_user_wants_dsc_data(hObject);
handles = guidata(hObject);
if isfield(handles, 'wants_roi'); if isnan(handles.wants_roi); return; end; end
initialise_roi_placement(hObject);
prepare_sliders_4D(hObject)
initialise_dynamic_plot(hObject);
end


function prepare_sliders_2D(hObject)
handles = guidata(hObject);
dummy_data = handles.axes2_data(:); dummy_data(~isfinite(dummy_data)) = []; dummy_data(isnan(dummy_data)) = [];
% dummy_mean = mean(dummy_data);
% dummy_std = std(dummy_data);
% dummy_data(dummy_data > (dummy_mean + 4*dummy_std)) = [];
% dummy_data(dummy_data < (dummy_mean - 4*dummy_std)) = [];
clim_max = double(max(dummy_data(:))) + 1E-10;
clim_min = min(dummy_data);
if clim_max <= 99; step_small = clim_max/1000; step_big = clim_max/999; end
if clim_max > 99; step_small = 1/clim_max; step_big = step_small; end
handles.axes2_image = imshow(handles.axes2_data, 'colormap', gray, 'Parent', handles.axes2);
handles.axes2.CLim = [clim_min clim_max];
title(handles.axes1, handles.axes2_filename, 'Interpreter', 'none')
set(handles.slider7, 'Min', clim_min, 'Max', clim_max, ...
    'SliderStep', [step_small, step_big], 'Value', clim_max)
set(handles.slider11, 'Visible', 'on') %color setting
set(handles.slider11, 'Min', clim_min, 'Max', clim_max-1E-10, ...
    'SliderStep', [step_small, step_big], 'Value', clim_min)
guidata(hObject, handles)
end

function prepare_sliders_3D(hObject)
handles = guidata(hObject);
set(handles.slider2, 'Visible', 'on')
set(handles.slider7, 'Visible', 'on')
set(handles.slider11, 'Visible', 'on')
set(handles.slider9, 'Visible', 'off')
set(handles.pushbutton16, 'Visible', 'on')
set(handles.pushbutton18, 'Visible', 'off')%rotate image on axes2, not allowed anymore due to ROI placement
set(handles.togglebutton3, 'Visible', 'on')
current_slice = round(handles.size_axes2_data(3)/2) ;
handles.axes2_image = imshow(squeeze(handles.axes2_data(:,:,current_slice)), 'colormap', gray, 'Parent', handles.axes2);
dummy_data = handles.axes2_data(:); dummy_data(~isfinite(dummy_data)) = []; dummy_data(isnan(dummy_data)) = [];
% dummy_mean = mean(dummy_data);
% dummy_std = std(dummy_data);
% dummy_data(dummy_data > (dummy_mean + 4*dummy_std)) = [];
% dummy_data(dummy_data < (dummy_mean - 4*dummy_std)) = [];
clim_max = double(max(dummy_data(:))) + 1E-10;
clim_min = min(dummy_data);
if clim_max <= 99; step_small = clim_max/1000; step_big = clim_max/999; end
if clim_max > 99; step_small = 1/clim_max; step_big = step_small; end
handles.axes2.CLim = [clim_min clim_max];
set(handles.slider2, 'Min', 1, 'Max', handles.size_axes2_data(3), ... %slices
    'SliderStep', [1, 1]/(handles.size_axes2_data(3) - 1), 'Value', current_slice)
set(handles.slider7, 'Visible', 'on') %color setting
set(handles.slider7, 'Min', clim_min, 'Max', clim_max, ...
    'SliderStep', [step_small, step_big], 'Value', clim_max)
set(handles.slider11, 'Visible', 'on') %color setting
set(handles.slider11, 'Min', clim_min, 'Max', clim_max-1E-10, ...
    'SliderStep', [step_small, step_big], 'Value', clim_min)
title(handles.axes1, handles.axes2_filename, 'Interpreter', 'none')
guidata(hObject, handles)
end

function prepare_sliders_4D(hObject)
handles = guidata(hObject);
set(handles.slider2, 'Visible', 'on')
set(handles.slider7, 'Visible', 'on')
set(handles.slider11, 'Visible', 'on')
set(handles.slider9, 'Visible', 'on')
set(handles.pushbutton16, 'Visible', 'on')
set(handles.pushbutton18, 'Visible', 'off')%rotate image on axes2
set(handles.togglebutton3, 'Visible', 'on')
current_slice = round(handles.size_axes2_data(3)/2);
current_timepoint = 1;
handles.axes2_image = imshow(squeeze(handles.axes2_data(:,:,current_slice,current_timepoint)), 'colormap', gray, 'Parent', handles.axes2);
dummy_data = handles.axes2_data(:); dummy_data(~isfinite(dummy_data)) = []; dummy_data(isnan(dummy_data)) = [];
% dummy_mean = mean(dummy_data);
% dummy_std = std(dummy_data);
% dummy_data(dummy_data > (dummy_mean + 4*dummy_std)) = [];
% dummy_data(dummy_data < (dummy_mean - 4*dummy_std)) = [];
clim_max = double(max(dummy_data(:))) + 1E-10;
clim_min = min(dummy_data);
if clim_max <= 99; step_small = clim_max/100; step_big = clim_max/99; end
if clim_max > 99; step_small = 1/clim_max; step_big = step_small; end
handles.axes2.CLim = [clim_min clim_max];
set(handles.slider2, 'Min', 1, 'Max', handles.size_axes2_data(3), ... %1st and 2nd dimensions
    'SliderStep', [1, 1]/(handles.size_axes2_data(3) - 1), 'Value', current_slice)
set(handles.slider7, 'Visible', 'on') %color setting
set(handles.slider7, 'Min', clim_min, 'Max', clim_max, ...
    'SliderStep', [step_small, step_big], 'Value', clim_max)
set(handles.slider11, 'Visible', 'on') %color setting
set(handles.slider11, 'Min', clim_min, 'Max', clim_max-1E-10, ...
    'SliderStep', [step_small, step_big], 'Value', clim_min)
set(handles.slider9, 'Min', 1, 'Max', handles.size_axes2_data(4), ... %4th dimension
    'SliderStep', [1, 1]/(handles.size_axes2_data(4) - 1), 'Value', 1)
title(handles.axes1, handles.axes2_filename, 'Interpreter', 'none')
guidata(hObject, handles)
end

function initialise_roi_placement(hObject, ~)
handles = guidata(hObject);
max_N_roi = 128*128;
handles.roi_counter = 0;
handles.rois = gobjects(max_N_roi,1);
handles.roi_slices = zeros(max_N_roi, 1);
if numel(handles.size_axes2_data) > 2
    handles.roi_mask = false(handles.size_axes2_data(1:3));
else
    handles.roi_mask = false(handles.size_axes2_data);
end
guidata(hObject, handles)
end


function addROI(hObject, ~, ~)
%adds 1 ROI when called
handles = guidata(hObject);
roi = drawfreehand(handles.axes2, 'Color', 'r', 'LineWidth',1, 'FaceAlpha', 0);
handles.roi_counter = handles.roi_counter+1;
handles.rois(handles.roi_counter) = roi;
if numel(handles.size_axes2_data) > 2
    handles.roi_slices(handles.roi_counter) = get(handles.slider2, 'value');
end
guidata(hObject, handles) %update master copy
end


function clearROIs_2D(hObject, ~, ~)
%clear all drawn ROIS
reset_axes1(hObject);
handles = guidata(hObject);
active_rois = handles.rois(ishandle(handles.rois));
% active_roi_slices = handles.roi_slices(ishandle(handles.rois));
for c_ar = 1:numel(active_rois)
    delete(active_rois(c_ar))
end
cmap = handles.axes2.Colormap;
cla(handles.axes2, 'reset')
guidata(hObject, handles)
initialise_roi_placement(hObject)
prepare_sliders_2D(hObject)
set(handles.axes2, 'Colormap', cmap)
end

function clearROIs_3D(hObject, ~, ~)
%clear all drawn ROIS
reset_axes1(hObject);
handles = guidata(hObject);
clim_im = get(handles.axes2, 'CLim');
active_rois = handles.rois(ishandle(handles.rois));
% active_roi_slices = handles.roi_slices(ishandle(handles.rois));
for c_ar = 1:numel(active_rois)
    delete(active_rois(c_ar))
end
current_slice = round(get(handles.slider2, 'Value'));
cmap = handles.axes2.Colormap;
cla(handles.axes2, 'reset')
handles.axes2_image = imshow(zeros(handles.size_axes2_data(1:2)), clim_im, 'colormap', cmap, 'Parent', handles.axes2);
set(handles.axes2_image, 'CData', (squeeze(handles.axes2_data(:,:,current_slice))) )
guidata(hObject, handles)
initialise_roi_placement(hObject)
end

function clearROIs_4D(hObject, ~, ~)
%clear all drawn ROIS
reset_axes1(hObject);
handles = guidata(hObject);
clim_im = get(handles.axes2, 'CLim');
active_rois = handles.rois(ishandle(handles.rois));
% active_roi_slices = handles.roi_slices(ishandle(handles.rois));
for c_ar = 1:numel(active_rois)
    delete(active_rois(c_ar))
end
ch = get(handles.axes1, 'Children');
for cc = 1:numel(ch)
    if ~strcmp(ch(cc).DisplayName, 'Mouse tracking'); delete(ch(cc)); end
end
current_slice = round(get(handles.slider2, 'Value'));
current_timepoint = round(get(handles.slider9, 'Value'));
current_cmap = handles.axes2.Colormap;
cla(handles.axes2, 'reset')
handles.axes2_image = imshow(zeros(handles.size_axes2_data(1:2)), clim_im, 'colormap', current_cmap, 'Parent', handles.axes2);
set(handles.axes2_image, 'CData', (squeeze(handles.axes2_data(:,:,current_slice, current_timepoint))) )
guidata(hObject, handles)
initialise_roi_placement(hObject)
initialise_dynamic_plot(hObject)
end

function Show2D(hObject, ~, ~)
handles = guidata(hObject);
reset_axes1(hObject)
active_rois = handles.rois(ishandle(handles.rois));
roi_mask = false(handles.size_axes2_data); %total mask
img_size = handles.size_axes2_data;
axes2_data = handles.axes2_data;
for c_roi = 1:numel(active_rois) %use meshgrid if this is slow
    h_roi = active_rois(c_roi);
    tmp_mask = false(handles.size_axes2_data); %individual mask
    for x = 1:img_size(1)
        for y = 1:img_size(2)
            if inROI(h_roi, x,y)
                tmp_mask(y,x) = true;
            end
        end
    end
    roi_mask = roi_mask | tmp_mask; %merge into total mask
end
ydata = axes2_data(roi_mask);
histogram(handles.axes1, ydata, 'FaceColor', 'k');
ymean = mean(ydata);
ystd = std(ydata);
legend(handles.axes1, "Mean = "+ num2str(round(ymean,2)) + ";  Std = " + num2str(round(ystd, 2)))
set(handles.axes1, 'fontsize', 11)
ylabel(handles.axes1, 'Count')
xlabel(handles.axes1, 'Value')
guidata(hObject, handles)
end


function visualise_photos(hObject)
handles = guidata(hObject);
handles.axes2_image = imshow(handles.axes2_data, 'Parent', handles.axes2); %ensure correct visualisation of rgb photos
set(handles.slider2, 'Visible', 'off') %slice
set(handles.slider7, 'Visible', 'on')
set(handles.slider11, 'Visible', 'on')
set(handles.slider9, 'Visible', 'off') %time point
set(handles.pushbutton16, 'Visible', 'on')
set(handles.pushbutton18, 'Visible', 'on')%rotate image on axes2
set(handles.togglebutton3, 'Visible', 'on')
title(handles.axes2, handles.axes2_filename, 'Interpreter', 'none')
guidata(hObject, handles)
end


function Show3D(hObject,~, ~)
handles = guidata(hObject);
reset_axes1(hObject)
active_rois = handles.rois(ishandle(handles.rois));
active_roi_slices = handles.roi_slices(ishandle(handles.rois));

roi_mask = false(handles.size_axes2_data); %total mask
img_size = handles.size_axes2_data;
axes2_data = handles.axes2_data;

for c_roi = 1:numel(active_rois) %use meshgrid if this is slow
    h_roi = active_rois(c_roi);
    roi_slice = active_roi_slices(c_roi);
    tmp_mask = false(handles.size_axes2_data(1:2)); %individual mask
    for x = 1:img_size(1)
        for y = 1:img_size(2)
            if inROI(h_roi, x,y)
                tmp_mask(y,x) = true;
            end
        end
    end
    roi_mask(:,:,roi_slice) = roi_mask(:,:,roi_slice) | tmp_mask; %merge into total mask
end
ydata = axes2_data(roi_mask);
histogram(handles.axes1, ydata, 'FaceColor', 'k');
ymean = mean(ydata);
ystd = std(ydata);
legend(handles.axes1, "Mean = "+ num2str(round(ymean,2)) + ";  Std = " + num2str(round(ystd, 2)))
set(handles.axes1, 'fontsize', 11)
ylabel(handles.axes1, 'Count')
xlabel(handles.axes1, 'Value')
guidata(hObject, handles)
end


function Show4D(hObject, ~, ~)
reset_axes1(hObject);
initialise_dynamic_plot(hObject);
handles = guidata(hObject);
active_rois = handles.rois(ishandle(handles.rois));
active_roi_slices = handles.roi_slices(ishandle(handles.rois));

roi_mask = false(handles.size_axes2_data(1:3)); %total mask
img_size = handles.size_axes2_data;

if handles.use_dsc_data_for_roi
    axes2_data = handles.axes2_data_2;
else
    axes2_data = handles.axes2_data;
end


hold(handles.axes1, 'on')

for c_roi = 1:numel(active_rois) %use meshgrid if this is slow
    h_roi = active_rois(c_roi);
    roi_slice = active_roi_slices(c_roi);
    tmp_mask = false(handles.size_axes2_data(1:2)); %individual mask
    for x = 1:img_size(1)
        for y = 1:img_size(2)
            if inROI(h_roi, x,y)
                tmp_mask(y,x) = true;
            end
        end
    end
    roi_mask(:,:,roi_slice) = roi_mask(:,:,roi_slice) | tmp_mask; %merge into total mask
end
Npixels = sum(roi_mask, 'all');
Nx = handles.size_axes2_data(4);
ydata  = zeros(Npixels, Nx);
c_ydata = 0;
for x = 1:img_size(1)
    for y = 1:img_size(2)
        for z = 1:img_size(3)
            if roi_mask(x,y,z)
                c_ydata = c_ydata+1;
                ydata(c_ydata, :) = squeeze(axes2_data(x,y,z,:));
            end
        end
    end
end

if handles.use_dsc_data_for_roi
    x = handles.t;
else
    x = 1:img_size(4);
end

for c = 1:c_ydata
    plot(handles.axes1, x, ydata(c, :), '-', 'LineWidth', 0.2, 'Color', [0.7 0.7 0.7], 'HandleVisibility', 'off')
end
ystd = std(ydata, 0, 1);
ymean = mean(ydata, 1);

if numel(ymean) <= 5; stil = 'o-'; else; stil = '-'; end
plot(handles.axes1, x, ymean, stil, 'Color', 'k', 'Linewidth', 3)
plot(handles.axes1, x, ymean+ystd, 'k--', 'Linewidth', 2)
plot(handles.axes1, x, ymean-ystd, 'k--', 'Linewidth', 2, 'HandleVisibility', 'off')
% ylim(handles.axes1, [0.5*min(ydata(:)), 2*max(ydata(:))])
% legstr = handles.axes1.Legend.String;
legend(handles.axes1, ["Mouse tracking", "Mean", "\pm 1 std"])
guidata(hObject, handles)
end


function change_slice_3D(hObject, ~, ~)
handles = guidata(hObject);
current_slice = round(get(hObject, 'Value'));
set(handles.axes2_image, 'CData', squeeze(handles.axes2_data(:,:,current_slice)))
active_rois = handles.rois(ishandle(handles.rois));
active_roi_slices = handles.roi_slices(ishandle(handles.rois));
set(active_rois, 'Parent', []);
set(active_rois(active_roi_slices == current_slice), 'Parent', handles.axes2);
% title(handles.axes1, ['Signal: Slice ' num2str(current_slice) ' : Time point ' num2str(current_time_point)])
guidata(hObject, handles)
end

function change_slice_4D(hObject, ~, ~)
handles = guidata(hObject);
current_slice = round(get(hObject, 'Value'));
current_time_point = round(get(handles.slider9, 'Value'));
set(handles.axes2_image, 'CData', squeeze(handles.axes2_data(:,:,current_slice,current_time_point)))
active_rois = handles.rois(ishandle(handles.rois));
active_roi_slices = handles.roi_slices(ishandle(handles.rois));
set(active_rois, 'Parent', []);
set(active_rois(active_roi_slices == current_slice), 'Parent', handles.axes2);
% title(handles.axes1, ['Signal: Slice ' num2str(current_slice) ' : Time point ' num2str(current_time_point)])
guidata(hObject, handles)
end



function initialise_dynamic_plot(hObject)
handles = guidata(hObject);
%seek y axis limits
reset_axes1(hObject);
hold(handles.axes1, 'on')
if handles.use_dsc_data_for_roi
    axes2_data = handles.axes2_data_2;
else
    axes2_data = handles.axes2_data;
end
size_axes2_data = size(axes2_data);

dummy_data = axes2_data(:); dummy_data(~isfinite(dummy_data)) = []; dummy_data(isnan(dummy_data)) = [];
% if max(dummy_data) > 1
%     dummy_mean = mean(dummy_data);
%     dummy_std = std(dummy_data);
%     dummy_data(dummy_data > (dummy_mean + 5*dummy_std)) = [];
%     dummy_data(dummy_data < (dummy_mean - 5*dummy_std)) = [];
% end
ymin = min(dummy_data);
ymax = max(dummy_data);
handles.dynamic_plot = plot(handles.axes1,1:size_axes2_data(4), NaN(1,size_axes2_data(4)), 'r:', 'LineWidth', 2);
if handles.use_dsc_data_for_roi
    set(handles.axes1,'XLim', [floor(min(handles.t)) ceil(max(handles.t))])
else
    set(handles.axes1, 'XLim', [1 handles.size_axes2_data(4)])
end
set(handles.axes1, 'YLim', [ymin ymax])
set(handles.axes1, 'Linewidth', 1.2, 'fontsize', 11)
xlabel(handles.axes1, 'Index')
ylabel(handles.axes1, '4th dimension')
legend(handles.axes1, "Mouse tracking")
grid(handles.axes1, 'minor')
guidata(hObject, handles)
end


function change_timepoint(hObject, ~ , ~)
handles = guidata(hObject);
time_point = round(get(hObject,'Value'));
current_slice = round(get(handles.slider2,'Value'));
set(handles.axes2_image, 'CData', squeeze(handles.axes2_data(:,:,current_slice, time_point))  )
% title(handles.axes1, ['Signal' ': Slice ' num2str(current_slice) ' : Time-point ' num2str(time_point)],...
%     'Interpreter', 'None')
guidata(hObject, handles)
end

function mouseMove(hObject, ~, ~)
handles = guidata(hObject);
if ~isfield(handles, 'axes2_image'); return; end
if ~ishandle(handles.axes2_image); return; end
C = get(handles.axes2, 'CurrentPoint');
x = round(C(1,1)); %these are flipped
y = round(C(1,2));
sl = get(handles.slider2, 'value');
try
    if handles.use_dsc_data_for_roi
        ydata = squeeze(handles.axes2_data_2(y,x,sl,:));
    else
        ydata = squeeze(handles.axes2_data(y,x,sl,:));
    end
    set(handles.dynamic_plot, 'YData', ydata); drawnow
catch
end
guidata(hObject, handles)
end

function reset_axes1(hObject)
handles = guidata(hObject);
cla(handles.axes1, 'reset')
% set(handles.axes1,'XTick', [], 'YTick', [], 'box', 'on') %set default appearance for axes
set(handles.axes1,'box', 'on')
set([handles.pushbutton24, handles.pushbutton25,handles.pushbutton26, handles.pushbutton27, handles.pushbutton30], 'Visible', 'off') % turn off all these buttons in case they are on
 set([handles.slider1, handles.slider8, handles.slider6, handles.slider10, handles.pushbutton15, handles.pushbutton17, handles.togglebutton2], 'Visible', 'off')
guidata(hObject, handles)
end

function check_if_user_wants_dsc_data(hObject)
handles = guidata(hObject);
if strcmp(handles.axes2_filename, 'residue_functions_BzD') || strcmp(handles.axes2_filename,'residue_functions_SVD')
    opts.Interpreter = 'tex';
    opts.Default = 'DSC images';
    response = questdlg(['\fontsize{10} Program allows ROI placement on DSC images' ...
        'for plotting of residue functions. Select where to perform ROI placement.'], ...
        'DECONVOLVER', 'R(t) images', 'DSC images', 'Cancel', opts);
    switch response
        case 'R(t) images'; wants_dsc = false;
        case 'DSC images'; wants_dsc = true;
        case 'Cancel'; set(handles.edit7, 'String', 'Data visualisation terminated by user.', 'ForeGroundColor', 'r'); handles.wants_roi = NaN;
            guidata(hObject, handles); return;
        case ''; set(handles.edit7, 'String', 'Data visualisation terminated by user', 'ForeGroundColor', 'r');
            handles.wants_roi = NaN; guidata(hObject, handles); return;    
    end
    if wants_dsc
%         if ~handles.dsc_data_loaded
            get_dsc_data(hObject)
            prepare_dsc_data(hObject)
            handles = guidata(hObject);
%         end
        handles.use_dsc_data_for_roi = true;
        handles.axes2_data_2 = handles.axes2_data;
        handles.axes2_data = handles.dsc_data_filtered;
        size_axes2_data = size(handles.axes2_data_2);
        handles.size_axes2_data = size_axes2_data;
        handles.path_to_axes2_data = handles.path_to_data;
        handles.axes2_filename = handles.file_name;
        guidata(hObject, handles)
        prepare_sliders_4D(hObject)
    end
else
    handles.use_dsc_data_for_roi = false;
    guidata(hObject, handles)
end
end


function get_dsc_data(hObject) %this is just a copy of the callback for pushbutton19, lousy
handles = guidata(hObject);
if isfield(handles, 'file_folder')
    [file, path] = uigetfile( '*.*','Select DSC-MRI data to analyse', handles.file_folder);
else
    [file, path] = uigetfile('*.*','Select DSC-MRI data to analyse');
end
if file == 0 %if user cancels file selection dialog
    wrap_text = 'No data selected for visualisation.'; %report this on display panel
    set(handles.edit7, 'String', wrap_text, 'ForegroundColor', 'r')
    return %terminate execution
end
path_to_data = fullfile(path, file); %otherwise generate full file path
[file_folder, file_name, ~] = fileparts(path_to_data); %extract folder name, file name and file extension
%TODO
%Check that file_ext is nii
%Display file path in a separate panel on main window. This panel
%is static
handles.file_folder = file_folder;
handles.file_name = file_name;
guidata(hObject, handles)
%__________________________________________________________________________
[dsc_data, mask, header_info] = load_dsc_data_gui(path_to_data, handles); %this function loads the data, generates a mask, and returns header info
handles.file_name = file_name;
handles.header_info = header_info;
handles.dsc_data = dsc_data;
handles.mask = mask;
handles.img_size = size(dsc_data);
handles.path_to_data = path_to_data;
%TODO
if ~isequal(dsc_data, false)
    handles.dsc_data_loaded = true;
    wrap_text = {'- - - - DSC data path - - - -'; handles.path_to_data}; %report this on display panel
    set(handles.edit14, 'String', wrap_text, 'ForegroundColor', 'b')
else
    return
end
%display some message on the static panel
%GET TE TR
[te, tr] = get_te_tr(handles); %get te and tr
if te == false && tr == false %if that fails, report and terminate
    wrap_text = 'Analysis terminated by user.';  set(handles.edit7, 'String', wrap_text, 'ForegroundColor', 'r'); return
else
    handles.te = te; handles.tr = tr;
    handles.t = 0:tr:(handles.img_size(4)-1)*tr;
end
%Target folder for saving results
% handles.target_folder = generate_target_folder(handles);

% GENERATE WHOLE-BRAIN SIGNAL CURVE
handles.baseline_index = 4:10; %baseline images: first 10 images excluding the first 3
handles.tail_index = handles.img_size(4)-5:handles.img_size(4); %tail: last five images
handles.plot_whole_brain_curve = false;
[~, t_min_signal] = whole_brain_curve_gui(handles); %generate it
handles.t_min_signal = t_min_signal; %save the time point where minimum signal occurs
report('DSC-MRI data loaded successfully.', handles)
guidata(hObject, handles)
end


function prepare_dsc_data(hObject)
handles = guidata(hObject);
if isfield(handles, 'mask') %if mask has been generated
    handles.dsc_data_filtered = handles.dsc_data.*0;
    for sl = 1:handles.img_size(3) %filter image to be displayed using the mask
        for tp = 1:handles.img_size(4)
            handles.dsc_data_filtered(:,:,sl, tp) = squeeze(handles.dsc_data(:,:,sl, tp)).*squeeze(handles.mask(:,:,sl));
        end
    end
else
    handles.dsc_data_filtered = handles.dsc_data;
end
guidata(hObject, handles)
end